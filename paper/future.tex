\section{Future Directions}
\label{sec:future}

In this paper we have provided a survey on work to adapt two
powerful program analysis frameworks, data flow analysis and symbolic
execution, to incorporate probabilistic reasoning.  This work has
already motivated exciting advances in model counting and solution
space quantification as discussed in Section~\ref{sec:computingprobabilities}.

As in other areas of program analysis, a mutually reinforcing cycle of
developments in algorithms, tools, and applications
is poised to spur further advances.  We believe that efforts to focus
probabilistic program analyses techniques on applications will reveal
new opportunities for adapting algorithms to be more efficient and
effective. This will, in turn, inspire researchers to identify
additional applications of these techniques.   Towards this end we
describe several areas where application of probabilistic program
analyses has potential and identify opportunities for cross-fertilization
among probabilistic analysis techniques.

\begin{enumerate}

\item Program understanding has been touched on in \cite{Geldenhuys2012} and \cite{Filieri2015} where errors are found by observing unexpected probabilities for certain behaviors.  This provides a means of quantifying the notion of ``bugs as deviant behavior'' that underlies much work on fault detection.   While numeric characterizations of distributions may be difficult for developers to interpret, visualizations of those distributions might allow them to spot unexpected patterns to focus their attention on.

\item Probabilistic symbolic execution is particularly well-suited for quantifying the difference between two versions of a program~\cite{Filieri2015b}. This makes it an ideal approach to rank how close a program is to a given oracle program, which has applications in mutation analysis, program repair, approximate computing or even in marking student assignments.  Note that this provides a route to a semantic ranking of programs as opposed to more syntactic rankings, e.g., by measuring the shared syntactic structure. 

\item Probabilistic programming is becoming very popular \cite{Gordon2014}, but the current approaches mainly focus on sampling, whereas a more accurate approach would be to use probabilistic symbolic execution.  
To achieve this, symbolic execution must be extended to support
\texttt{observe(e)} statements which condition input on a boolean expression,
$e$, by aborting the path if the expression is false and renormalizing the
output distribution.
Most existing symbolic execution frameworks already support \texttt{assume} and \texttt{assert} statements to check and enforce predicates at program points.
Extending this to support \texttt{observe} requires that the probability
estimates of aborted paths be accumulated to permit renormalization at the
end of the symbolic execution.  We note that relative to existing probabilistic
symbolic execution approaches this adds negligable overhead.

\item Probabilistic programs, in the sense of \cite{Gordon2014}, can be used
to define a distribution.  This means that they could be a useful means of
summarizing probability information for modular probabilistic program analysis.
A program could define the input distribution, and the output distribution
could then be converted to a program---the pair would form a probabilistic
contract of sorts.

\item It would be interesting to explore the extent
to which the computation of branch probabilities---which annotate
models in tools like like PRISM \cite{kwiatkowska2011prism} and 
PASS \cite{hahn2010pass}---could be achieved,
in part, by using path condition calculation and solution
space quantification techniques drawn from probabilistic symbolic
execution.  

\item Hybrid approaches that mix probabilistic symbolic execution
and data flow seem promising.  The unanalyzed portion of a program's
symbolic execution tree defines a ``residual'' program.  If that
program can be extracted, via techniques like slicing, then it
could be encoded for analysis with data flow techniques.  The
results of the precise-but-slow, and faster-but-less-precise,
analysis, could then be combined. 

\end{enumerate}
