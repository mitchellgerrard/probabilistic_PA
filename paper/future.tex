\section{Future Directions}
\label{sec:future}

There are many applications for probabilistic program analysis, but most work so far has focused on the probability of failure/success of a program under varying input distributions; i.e., the focus has mainly been on reliability.
Here we suggest avenues for further development and application of
probabilistic program analyses.

\begin{enumerate}

\item Program understanding has been touched on in \cite{Geldenhuys2012} and \cite{Filieri2015} where errors are found by observing unexpected probabilities for certain behaviors.  This provides a means of quantifying the notion of ``bugs as deviant behavior'' that underlies much work on fault detection.   While numeric characterizations of distributions may be difficult for developers to interpret, visualizations of those distributions might allow them to spot unexpected patterns to focus their attention on.

\item Probabilistic symbolic execution is particularly well suited for quantifying the difference between two versions of a program~\cite{Filieri2015b}. This makes it an ideal approach to rank how close a program is to a given oracle program, which has applications in mutation analysis, program repair, approximate computing or even in marking student assignments.  Note that this provides a route to a semantic ranking of programs as opposed to more syntactic rankings, e.g., by measuring the shared syntactic structure. 

\item Probabilistic programming is becoming very popular \cite{Gordon2014}, but the current approaches mainly focus on sampling, whereas a more accurate approach would be to use probabilistic symbolic execution.  
To achieve this symbolic execution must be extended to support
\texttt{observe(e)} statements which condition input on a boolean expression,
$e$, by aborting the path if the expression is false and renormalizing the
output distribution.
Most existing symbolic execution frameworks already support \texttt{assume} and \texttt{assert} statements to check and enforce predicates at program points.
Extending this to support \texttt{observe} requires that the probability
estimates of aborted paths be accumulated to permit renormalization at the
end of the symbolic execution.  We note that relative to existing probabilistic
symbolic execution approaches this adds no overhead.

\item Probabilistic programs, in the sense of \cite{Gordon2014}, can be used
to define a distribution.  This means that they could be a useful means of
summarizing probability information for modular probabilistic program analysis.
A program could define the input distribution, and the output distribution
could then be converted to a program---the pair would form a probabilistic
contract of sorts.

\item It would be interesting to explore the extent
to which the computation of branch probabilities---which annotate
models in tools like like PRISM \cite{kwiatkowska2011prism} and 
PASS \cite{hahn2010pass}---could be achieved,
in part, by using path condition calculation and solution
space quantification techniques drawn from probabilistic symbolic
execution.  

\item Hybrid approaches that mix probabilistic symbolic execution
and data flow seem promising.  The unanalyzed portion of a program's
symbolic execution tree defines a ``residual'' program.  If that
program can be extracted, via techniques like slicing, then it
could be encoded for analysis with data flow techniques.  The
results of the precise-but-slow, and faster-but-less-precise,
analysis, could then be combined. 

\end{enumerate}
