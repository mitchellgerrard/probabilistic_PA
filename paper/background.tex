\section{Scope and Background}
\label{sec:background}

\ignore{
\begin{enumerate}
\item abstraction refinement
\item fixpoint
\end{enumerate}
}

We focus in this paper on programs that draw input variables
from given probability distributions, or equivalently that make
calls on functions returning values drawn from given distributions
such as those provided by the C++ \texttt{<random>} library.
\mycomment{We should pull an example from one of the later sections
back here to illustrate the idea.}

While researchers have developed analyses that consider a wide
range of program properties, in this survey
we restrict our attention to program
properties that can be encoded as boolean predicates that
can be embedded in the program,
e.g., \texttt{assert} statements, to simplify the explanation
of how probabilities are incorporated into the analyses.
These are refered to as \textit{invariant properties} since
they are intended to hold at every state reached
in all program program executions

\subsection{Programs and Program Analyses}
A program defines a set of execution \textit{traces} each of
which is a sequence of \textit{concrete states}, i.e., 
the current program counter and a map from memory locations to values.
A program \textit{satisfies} an invariant property if in all states in
all traces the predicate evaluates to true, otherwise the program
\textit{falsifies} the property.

A key concept in the program analysis frameworks we survey is
\textit{symbolic abstraction}.  A symbolic abstraction is a 
representation of a set of states.  Abstractions can be encoded
in a variety of forms, e.g., logical formula or binary
decision diagrams \cite{BDD}.  

Analyses that seek to prove the satisfaction of properties generally
define abstractions that \textit{overapproximate} the set of program
states, whereas those that seek to falsify properties generally define
abstractions that \textit{underapproximate} the set of program states.

With overapproximating analyses it is common to define an \textit{abstract
domain}, $\mathcal{A}$, 
which symbolically represents a set of concrete states which 
are said to be defined over the \textit{concrete domain}, $\mathcal{A}$.
For any reachable state of a program a pair of abstraction 
and concretization functions, 
$\alpha : \mathcal{C} \mapsto \mathcal{A}$ and  
$\gamma : \mathcal{A} \mapsto 2^\mathcal{C}$,
serve to relate the concrete and abstract domains such that 
$\forall c \in \mathcal{C} : \alpha(c) \in \mathcal{A}$ and $c \in \gamma(\alpha(c))$.
Such an abstract domain is typically partially ordered, $\sqsupseteq$,
so that 
$\forall a,a' \in \mathcal{A} :  a \sqsupseteq a' \implies \gamma(a) \supseteq \gamma(a')$.
Moreover, it is equipped with a meet operator, $\sqcap$, which
computes greatest lower bounds and a maximal
value, $\top \in \mathcal{A}$, such that 
$\forall a \in \mathcal{A} : a \sqcap \top = a$

\subsubsection{Data Flow Analysis}
Data flow analyses (and abstract interpretations) are 
non-standard interpretations of program executions over an abstract domain.  
The semantics of program statements is lifted to operate
on a set of states, encoded as an element of the abstract domain,
rather than a single concrete state.  
For a program statement $\tau$,
$\tau^\#$ defines its abstract semantics such that
$\forall c, c' \in \mathcal{C} : \tau(c) = c' \implies \tau^\#(\alpha(c)) \sqsupseteq \alpha(c')$.  This implies the classic overapproximating correctness
relation for abstracted program statements:
$\tau^\# \sqsupseteq \alpha \circ \tau \circ \gamma$.

Conceptually for a program trace, $tr_i$, the sequence of 
statements, $[\tau_1,\ldots,\tau_n]$, defining the trace can
be interpreted functionally, $tr_i^\# = \tau_{n}^\# \circ \ldots \tau_1^\#$,
and evaluated, $tr_i^\#(\iota)$,
to overapproximate the program states reached by the trace; 
hhere $\iota$ is the abstract state describing the initial program states.
The information from all traces, $T(l)$, leading to a program location, $l$, 
could then be combined, $\displaystyle\bigsqcap_j^{T(l)} tr_j^\#(\iota)$, to 
compute invariant properties that hold prior to executing $l$; this
is refered to as the meet-over-paths (MOP) solution.

This is impractical and instead the abstract states that hold at a
program location can be computed using Algorithm~\ref{alg-dfa}.
The algorithm stores abstract states, $a$, for each location, initializing
the first location to $\iota$, then proceeds along the control
flow relation of the program to approximate the effects of program
statements.  It removes a new location, $l$, and computes the abstract
state that approximates the post-state of executing the operation
at that location -- storing it in a temporary $t$.  Then for
all control flow successors it updates the abstract state for
that location by computing the greatest lower bound with $t$.
If that results in a new abstract state for the successor then
the successor is stored for future processing.  When the algorithm
terminates it computes for each location $l$ an approximation,
$a[l] \sqsubseteq \displaystyle\bigsqcap_j^{T(l)} tr_j^\#(\iota)$, 
of the MOP solution.
The nature of the approximation assures that $a[l]$ degines
invariant properties that hold prior to executing statement $l$.


\subsubsection{Model Checking}
\mycomment{Matt: will flesh this out if the above seems workable; I'm
a bit worried about space}

\subsubsection{Symbolic Execution}
\label{sec:back:symexe}

\mycomment{Matt: add definitions of underapproximation and whatever
else symbolic execution needs; walk through updated algorithm}

\noindent\begin{minipage}[t]{0.32\textwidth}
\begin{algorithm}[H]
%\renewcommand{\thealgorithm}{}
\renewcommand{\algorithmicindent}{0.6em}
\floatname{algorithm}{Alg.}
\caption{{\tt dfa}$(l_0,a)$}
\label{alg-dfa}
\begin{algorithmic}
 \STATE $a[l_0] \gets \iota$
 \STATE $\forall l \not= l_0 : a[l] \gets \top$
 \STATE $w \gets \{l_0\}$
 \WHILE{$w \not= \emptyset$}
   \STATE $l \gets remove(w)$
   \STATE $t \gets {op(l)}^{\#}(a[l])$
   \FOR{$l' \in succ(l)$}
     \STATE $a[l'] \gets (o \gets a[l']) \sqcap t$
     \IF{$a[l'] \not= o$}
       \STATE $w \gets w \cup \{l'\}$
     \ENDIF
   \ENDFOR
 \ENDWHILE
\end{algorithmic}
\end{algorithm}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\textwidth}
\begin{algorithm}[H]
%\renewcommand{\thealgorithm}{}
\renewcommand{\algorithmicindent}{0.6em}
\floatname{algorithm}{Alg.}
\caption{{\tt mc}$(l,u)$}
\label{alg-mc}
\begin{algorithmic}
 \WHILE{$\neg branch(l)$}
   \STATE $m \gets m\lrangle{v, e}$
   \STATE $l \gets succ(l)$
 \ENDWHILE
\end{algorithmic}
\end{algorithm}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\textwidth}
\begin{algorithm}[H]
%\renewcommand{\thealgorithm}{}
\renewcommand{\algorithmicindent}{0.6em}
\floatname{algorithm}{Alg.}
\caption{{\tt symx}$(l,m,\phi)$}
\label{alg-symexe}
\begin{algorithmic}
 \WHILE{$\neg branch(l)$}
   \STATE $m \gets \x{op}(l)(m)$
   \STATE $l \gets \x{succ}(l)$
 \ENDWHILE

 \STATE $c \gets $

 \IF{SAT$(\phi \wedge c)$}
   \STATE {\tt symx}$(\x{succ_t}(l), m, \phi \wedge c)$
 \ENDIF

 \IF{SAT$(\phi \wedge \neg c)$}
   \STATE {\tt symx}$(\x{succ_f}(l), m, \phi \wedge \neg c)$
 \ENDIF
\end{algorithmic}
\end{algorithm}
\end{minipage}

{\bf added by Corina, needs to aligned with algorithm}

%\subsection{Symbolic Execution}
Symbolic Execution~\cite{King1976,clarke76:system} is a program
analysis technique that executes programs on unspecified inputs, by
using symbolic inputs instead of concrete data. The state of a
symbolically executed program is defined by the (symbolic) values of
the program variables, a \emph{path condition} ($PC$), and a program
counter. The path condition is a (quantifier-free) boolean formula
over the symbolic inputs; it accumulates constraints on
the inputs to follow that path. The program counter defines the next
statement to be executed. Dynamic symbolic execution (or dynamic test generation or concolic execution)~\cite{godefroid05:dart,Cute,BitBlaze} is a variant of symbolic execution that builds path conditions along concrete program runs and systematically negates and solves collected constraints to drive the execution along different program paths. A key advantage of the technique is the ability of use execution data when symbolic constraints can not be solved. Further the technique has been shown to scale well in practice~\cite{SAGEsummaries}.

A \emph{symbolic execution tree} characterizes the execution paths
followed during symbolic execution. The tree nodes 
represent program states and the arcs the transitions between
states due to the execution of program instructions. Typical applications 
of symbolic execution include test case
generation and error detection, with many tools available
\cite{SPF,godefroid05:dart,tillman-halleux-tap2008,Klee}.
%Symbolic execution of looping programs may result in an infinite
%symbolic execution tree. For this reason, symbolic execution is
%typically run with a (user-specified) bound on the search depth.

Our previous work on probabilistic software analysis used
the symbolic execution tool Symbolic Java PathFinder (SPF)~\cite{SPF}, 
part of the Java PathFinder open-source verification framework. 
However, our algorithms are applicable in the context
of other languages for which symbolic execution tools exists such as
Klee~\cite{Klee} for C. 




\subsection{Probabilities and Probabilistic Models}
The probability of an event $e$ is written $Pr(e)$.

Define and explain the following
\begin{itemize}
\item probability measure
\item rewards/costs
\item discrete time Markov chain
\item discrete time Markov decision process
\end{itemize}

