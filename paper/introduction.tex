\section{Introduction}
\label{sec:introduction}

Program analyses aim to calculate properties of program executions 
that hold during execution.

Properties come in many flavors 
 - syntactic vs. semantic 
 - invariant vs. temporal
 - ...  

Properties have been put to many uses 
 - internal properties of implementations drive optimization 
 - checking implicit/explicit assertions and contracts within the code
 - checking output specifications
 - ...

A wide variety of analysis techniques have been developed
 - in cost and scalability
 - in the guarantees they provide about properties, e.g., precision
 - flow, path, calling, scheduling sensitivity
 - ...

The power of these techniques, and what distinguishes them from
simply running a program and observing its behavior, is in their
ability to account for uncertainty.
 
Uncertainty can come in different forms ...
 - data values
 - sequencing/timing
 - ...

... and it can be captured in models for program analysis in different ways
 - free variables
 - assumption specifications
 - non-deterministic choice
 - ...

Program analysis techniques have used this type of modeling
 - to abstract system behavior to reduce analysis cost while
   retaining desirable fidelity in properties computed by the
   analysis 
 - model refinement has been a key means of improving the utility 
   of analyses (to target specific behaviors, to eliminate misleading
   computing properties, to speed analysis)

There are limits to what can be achieved with "classic" program analyses
 - software systems are becoming less deterministic
   - machine learning
   - CPS systems and their real-world environments
   - probabilistic algorithms




