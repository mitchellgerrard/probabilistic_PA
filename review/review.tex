\documentclass[12pm]{article}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}

\usepackage{listings}
\usepackage{color}

\newcommand{\fixed}[1]{\textcolor{green}{Fixed #1}}
\newcommand{\recognize}[1]{\textcolor{blue}{#1}}
\newcommand{\ask}[1]{\textcolor{red}{#1}}

\begin{document}

----------------------- REVIEW 1 ---------------------

PAPER: 19

TITLE: Probabilistic Program Analysis

AUTHORS: Matthew Dwyer, Antonio Filieri, Jaco Geldenhuys, Mitchell Gerrard, Corina Pasareanu and Willem Visser

OVERALL EVALUATION: 2 (accept)

REVIEWER'S CONFIDENCE: 4 (high)

----------- Review -----------

This paper presents a survey of recent work on probabilistic
program analysis, showing how probabilistic information can be
used in data flow analysis and symbolic execution. The paper
gives the background knowledge, explains the key intuitions and
concepts, surveys the work on probabilistic data flow analysis
and symbolic execution, and highlights some open questions and
challenges.

The paper is well-written and easy to follow. The basic idea
behind each work is clearly explained, with some concrete
concrete examples.

To give a big picture of the related work, it would be nice if a
summary (table) can be provided to give a comparison among the
work discussed in the paper (showing their strength and weakness
in terms of power, efficiency, etc).

\fixed{We considered this suggestion, but many of dimensions
of comparison are conditioned on the specifics of how the analysis
frameworks are instantiated, e.g., the abstract domain, and
how those interact with program structure.  We have tried to
sharpen up the descriptions to better illustrate aspects
of comparison between approaches.}
 
Also, this paper is mainly about program analysis of imperative
programs (rather than functional or logic languages), so the
title looks a bit too general.

\fixed{We do focus on imperative programs and have added a statement
about this focus in the introduction.}

----------------------- REVIEW 2 ---------------------

PAPER: 19

TITLE: Probabilistic Program Analysis

AUTHORS: Matthew Dwyer, Antonio Filieri, Jaco Geldenhuys, Mitchell Gerrard, Corina Pasareanu and Willem Visser

OVERALL EVALUATION: 0 (borderline paper)

REVIEWER'S CONFIDENCE: 4 (high)

----------- Review -----------

1. Summary

Probabilistic techniques are more and more popular in programming.
Standard program analysis techniques such as data-flow analysis
and symbolic execution have to be extended to probabilism. The
literature in this respect is getting voluminous and there is a
need for a survey.

The main aim of this submission to provide a survey of the literature
on scaling up data-flow analysis and symbolic execution to the
probabilistic setting.

2. General comments

Probabilism is surely a ``grand timely topic in software engineering",
so this paper clearly fits into GTTSE. The need for a survey on
the program-analysis side of this trend is also justified by the
rapid spread of many seemingly disparate approaches which need
to be compared and evaluated.

Is the survey in this paper a successful and useful one? Perhaps
not. This is too long a paper, there is too much text. 

\fixed{We have trimmed the paper in length reducing some of the
broader survey elements to better focus on the main techniques
that we focus on.}

Instead
of simple, sharp examples, it relies on a single running example
which is confusing in places. 

\fixed{We have sharpened descriptions of how the analyses apply to
the example, e.g., we now describe how the 2-player game approach
applies to an MDP.}

Looking at Fig.1, I read
``if(drawBernoulli(0.5) == 1)" as picking a boolean from a distribution,
i.e. a quantitative way of expressing deterministic choice.
When further studying the paper, I made these two probabilistic
booleans explicit in the following functional program which relies
on a Haskell library available from the web (PFP):

\begin{lstlisting}

m :: Int -> Dist (Maybe Int)
m(x) = do {
  b1 <- distribution ;
  if b1
  then do {
     b2 <- distribution ;
     if b2
     then return (if x <= 60 then Just(...) else Nothing)
     else return (if x <= 30 then Just(...) else Nothing)
          }
  else return (if x <= 55 then Just(...) else Nothing)
} where distribution = .....

\end{lstlisting}

The `Nothings' in the program correspond to the `assert false' statements
and the type of `m' is clear: the input is an integer and the output is a
distribution of integers (or exceptions) generated by the internal probabilism
of the program.

The monadicity of `m(x)' makes it simple to cover another situation,

\begin{lstlisting}
  do { x <- d ; m(x) }
\end{lstlisting}

where `d' is a source of external probabilism; the script now maps input
distributions to output distributions of integers (or exceptions).

``Where do the probabilities come from?" (section 2.2). The Haskell
syntax makes this clear: `d' is a ``probabilistic integer" supplied
as input (external probabilism) while `b1' and `b2' are internal
``probabilistic booleans" generating probabilism inside the program.

I prefer the `internal/external' dichotomy rather than the `implicit/explicit'
one used in the paper. It furthermore has the advantage of being
consistent with similar choice of terminology in process algebra
(cf. external choice, internal nondeterminism, etc).

\fixed{The functional presentation of the example is quite interesting.
We agree that the functional setting does provide some clear advantages,
e.g., the analysis need not worry about side-effects.  Our goal
in this paper is to explain how imperative program analyses, which
have been widely studied, can be adapted to incorporate explicitly
specified probabilistic information about program inputs.  We have
clarified this focus in the introductory portions of the paper.}

The syntax of C doesn't help either. For instance, I must admit I got confused
on first reading type `m(int x, int b1, int b2) \{...' because I thought
the b1, b2 were integers such as x, e.g. ranging over [0,100] etc. Writing
``\textbackslash b.b=..." instead of ``\textbackslash x.x=..." would have helped, but the misinterpretation
was mine, not the authors'.

\fixed{We have rewritten the input constraints to clarify this.}

Section 3 of the paper stresses on Monniaux's view that ``probabilistic
programs effectively transform an input distribution into an output
distribution". This happens because Monniauxâ€™s approach is denotational.
In a sense, our probabilistic functional program above is the denotational
semantics of the imperative code given in the paper.

\fixed{Yes, we see that the monadicity of m(x) in your formulation exploits
the power of higher-order functions to shift between computing over probabilities
of input values and computing over distributions.}

Page 10: why an indexed collection of pairs A * [0,1]? Such pairs
don't repeat the `A's, so a function is enough, `pa : A $\mapsto$ [0,1]'.
Then `pr(c)' is simply given by `sum a : a $\in$ gamma(c) : pa(a)'.
(No indices needed.)

\fixed{Thank you for the question.  We have simplified our presentation
to remove the indexing since it is not needed to communicate the key
point of Monniaux's approach.}

Page 12, Handling nondeterminism: what do you mean by an ``empty
choice"? By the way: there have been significant advances in combining
probabilism with nondeterminism in a coalgebraic way, based on
suitable distributive laws - see e.g. DOI 10.1016/j.entcs.2006.06.004,
10.1007/978-3-642-32784-1\_7, 10.1016/j.jlamp.2015.11.007 among
others. Please compare these with the explicit MDP approach.

\ask{Matt: Antonio can you go ahead and make these changes?}
\recognize{Anto: I had a quick look at the first 2 references. They seem to correspond, at a semantic level, to Interval-MDPs (which include another level of nondeterminism to select a specific transition probability from within an interval; there is a nice paper at cav13 by Pugelli et al.). We can add these papers and Pugelli's one at the end of the 3rd par of ``Handling nondeterminism'' stating that ``Recent theoretical advances in the analysis of stochastic processes [pugelli] and the theory of coalgebras [those from the reviewer] may provide new pathways towards the definition of more advanced probabilistic program analysis methods that combine nondeterministic and probabilistic choices''}


Page 22, Future Directions: the paper mentions fault detection,
but probabilism is also helpful in studying fault (or risk)
propagation in the case of recursive programs, see e.g. 
DOI 10.1016/j.scico.2015.04.008.

\fixed{}

3. Further suggestions for improving the manuscript

The suggestions below either spot typos or propose different
(hopefully better) ways to rephrase the original text.

page 1, Abstract ``€œopportunities for future research that builds"
$\rightarrow$ ``opportunities for future research building" 
\fixed{this phrasing makes the parsing between ``future research" 
(pause) ``building" and an implicit ``future
research-building" slightly ambiguous, so we prefer the original}

page 2 Fix the spurious vertical space (LaTeX) 
\fixed{}

page 2, 3rd paragraph: I cannot see the text of footnote 1. 
\fixed{Moved the footnote up into the text}

page 3 ``We focus in this paper on programs" $\rightarrow$ ``This paper focuses
on programs"
\fixed{}

page 7: ``Markov chain, but the value of an MDP" $\rightarrow$ ``Markov chain,
but the advantage of an MDP"
\fixed{}

page 9: tell what ``DTMC" means.
\fixed{Because we introduce and discuss Markov chains only in the context of discrete time, we changed DTMC to just Markov chain.}

page 9: ``In that approach" $\rightarrow$ ``In this approach"
\fixed{We chose the phrasing ``In the latter approach" to disambiguate}

page 10: ``computes the probability with which a property holds"
$\rightarrow$ ``computes the probability of some property holding"
\fixed{}

page 11: ``Fundamentally, that requires" $\rightarrow$ ``In essence, this requires"
\fixed{}

page 11: ``from Section 3.3" $\rightarrow$ ``of Section 3.3"
\fixed{}

page 15: ``example from Figure 3" $\rightarrow$ ``example of Figure 3"
\fixed{}

page 15: ``import task" $\rightarrow$ ``important task"
\fixed{}

page 16: ``As more of the paths of the program are analyzed, counts
are being propagated up" $\rightarrow$ ``The more paths of the program are
analyzed, the more counts propagate up"
\fixed{}

page 16: ``In both of these works" $\rightarrow$ ``In both works"
\fixed{}

page 17: ``Efficient implementations" $\rightarrow$ ``As efficient implementations"
\fixed{}

page 18: ``this purpose, however, 1)" $\rightarrow$ ``this purpose. However: 1)"
\fixed{}

page 18: ``scale when the cardinality of the input domain grows"
$\rightarrow$ ``scale up to large cardinalities"
\fixed{}

page 19: sentence ``Given an input x, y, the constraint would either
be satisfied or violated" is ``une lapalissade" and as such should
be removed.
\fixed{}

page 22: ``cycle of algorithm and tool development coupled with
applications of analyses" $\rightarrow$ ``cycle of algorithm / tool developments
/ applications" 
\fixed{We changed the phrasing to be: ``cycle of
developments in algorithms, tools, and applications"}

page 22: ``efficient and effective and that this will," $\rightarrow$ ``efficient
and effective. This will,"
\fixed{}

page 24: ``counting for sat" $\rightarrow$ ``counting for SAT"
\fixed{}


----------------------- REVIEW 3 ---------------------

PAPER: 19

TITLE: Probabilistic Program Analysis

AUTHORS: Matthew Dwyer, Antonio Filieri, Jaco Geldenhuys, Mitchell Gerrard, Corina Pasareanu and Willem Visser

OVERALL EVALUATION: 2 (accept)

REVIEWER'S CONFIDENCE: 4 (high)

----------- Review -----------

This paper presents an introductory survey of probabilistic variants of program analyses with a focus on data flow analysis and static symbolic execution. Despite being dense at times, the paper does manage to convey the big ideas. Some familiarity with the original, non-probabilistic analyses will be required of the reader though. 

The structure of the paper is quite logical. I have but four minor suggestions for improvement:
- First, the link between Section 3.3 ``Computing Program Probabilities" and the preceding sections should be made more explicit. The reader is left wondering how these methods are to be incorporated in a probabilistic program analysis. It would be enlightening to refer to specific lines of the pseudo-algorithm for symbolic execution, and to Figure 1 which was used as a running example throughout the paper. An enumeration of program analyses from the literature that use the precise or a sampling-based method would complete the section. 

\ask{Matt: Antonio do you think you can find some ways to weave 3.3 into the other sections or at least cross-reference a bit.  You can leave a description of what you did here in the review response.}

- Second, Gordon et al's view on probabilistic programs is explained only in the footnote on page 3 ---while 2 of the 6 opportunities for future work refer to it. It would be better to explain this view wholly in the introduction or in the future work section. 

\fixed{}

- Third, I felt the work on probabilistic symbolic execution is explained more crisply than the work on probabilistic data flow analysis. Would it be possible to include a one-pager with the typical pseudo-algorithm for the monotone dataflow analysis framework (i.e., analogous to what page 14 does for static symbolic execution). This would improve the clarity of the first part of the paper.

\fixed{We had included this in a prior draft, but the feedback we received was that it made the survey too long.  We removed it to address that concern and since the analysis framework, e.g., of Kildall, is very clearly explained in the literature we felt that the reader would be better off with the details of the newer, and less well known, symbolic execution approach.}

- Fourth, some glue text is missing in key places. For instance, the structure of Section 3 should be announced before its first subsection. This glue text would be a good opportunity to link the aforementioned Subsection 3.3 to 3.1 and 3.2.
Also, a ``Conclusion" section is missing.

\fixed{TBD}

Minor issues in need of clarification:

p2: can the claim that frameworks for developing probabilistic program analyses have lagged behind be substantiated? e.g., by enumerating how few exist compared to non-probabilistic ones?
\fixed{}

p4: aren't the variants of symbolic execution described near the end of the page commonly referred to as dynamic symbolic execution (or concolic testing)?
\fixed{}

p6: However, it may be the case that phi fails to hold on some trace reaching $\rightarrow$ that phi holds on ... ?
\fixed{}

p8: ``and the number of values in the set." $\rightarrow$ please elaborate at this point \_why\_ this quantity is important (to improve the link to section 3.3)
\fixed{}

\fixed{p9: the acronym DTMCs is not yet defined (Because we introduce and discuss Markov chains only in the context of discrete time, we changed DTMC to just Markov chain.)}

p10: ``Ramalingam formulates an equivalent system of linear equations." Is it possible to make this equivalence more concrete?
\fixed{We considered this and to illustrate the equivalence would require nearly
half a page with an illustrative example.  Given the strong suggestions that we reduce the length of the survey we have chosen to not address your suggestion.}

p10: ``Within the last 15 years, began incorporating probabilistic program information directly into ..." Can the need for this shift be motivated using example applications?
\fixed{}

p10/11: ``of the abstract domain [element]?, but rather are bounds on the probability of each concrete [s/element/value]? represented by the abstract domain [element]?. The next sentence, starting with ``This simplifies ..." should be rewritten to improve its clarity.
\fixed{}

p11: In the part starting with ``The literature has constructed these ad-hoc techniques, but we believe the methods of Section 3.3 might be applied ...", it is unclear whether what follows are ``these ad-hoc techniques" or your belief. I recommend postponing the reference to Section 3.3 until after the ad-hoc techniques have been enumerated.
\fixed{}

p12: Isn't the reading of the leftmost trace of the MDP of Figure 2 missing the decision for the root node? i.e., shouldn't it have read as left: \_; left : \_; left ; 0.6?
\fixed{}

p15: the sentence starting with ``More specifically, how to ..." breaks the flow of the paragraph. I recommend omitting it. 
\fixed{We trimmed the paragraph and tried to smooth the flow.)}

p16: Which of the enumerated works under ``More and varied probabilistic symbolic execution" perform static and dynamic symbolic execution respectively?
\fixed{}

p22: I suggest merging future directions 3 and 4 (with the text of 4 taking precedence), and placing the merger at the back of the list. The others can be understood without understanding Gordon et al's view on probabilistic programs (cf. above). 
\fixed{TBD}

Spelling and typography:

p2: spurious space between citations and footnote
\fixed{}

p3: ``Example" is too generic as a caption for Figure 1; its three subfigures could be described instead
\fixed{}

p4: While abstractions encode sets of states\_,\_ abstract transformers ...
\fixed{}

p4: Data flow analyses [45] provides$\rightarrow$provide
\fixed{}

p4: , or \_a\_ set of states.
\fixed{}

p6: given by a function which$\rightarrow$that maps ..., a labeled transition system which$\rightarrow$that ..., for the conditions which$\rightarrow$that test ... 
\fixed{In the final case, we left
``which'' in, because the word ``that'' immediately follows ``test''}

p6: , it results in an MDP.$\rightarrow$Markov Decision Process (MDP).
\fixed{}

p7: as a program whose inputs $\rightarrow$ of which the inputs 
\fixed{Rephrased differently as the suggested
phrasing sounded awkward.}

p9: Early work in extending data flow analysis \_[enumerate the citations to the work in the following few paragraphs]\_
\fixed{}

p9: excepting the exit node $\rightarrow$ except for the exit node
\fixed{}

p9: of traces which can reach $\rightarrow$ of traces reaching / of traces that can reach
\fixed{}

p9: To compute ... at a program point, Ramalingam \_[cite 57]\_ uses ... (the citation at the end of this sentence refers to Ramalingam's work; cite 57 (Mehofer et al.) does not seem relevant here)
\fixed{}

p9: The restricted properties $\rightarrow$ The usual properties
\fixed{}

p10: whose solution $\rightarrow$ of which the solution 
\fixed{We changed the
phrasing to ``whose solution yields...''; ``of which the'' sounded awkward.}

p10: ``allows the expression of both control flow and data flow" $\rightarrow$ ``allows both control flow and data flow"
\fixed{}

p12: an input distribution \_, it is natural
\fixed{}

p13: domains of those variables consist\_ of
\fixed{}

p15: are no loops in the example\_,\_ the rest of the paths
\fixed{}

p15: a path is finished being explored $\rightarrow$ has been explored completely
\fixed{}

p16: model counting (using Latte) $\rightarrow$ add citation to [78] and forward reference to the next section
\fixed{}

p16: above is mistakenly set in texttt
\fixed{}

p17: A\_ LLIA constraint --the$\rightarrow$a conjunction
\fixed{}

p18: A number of commercial and open-source tools can be used for this purpose\_.\_ [Which ones?] However, ...
\fixed{Antonio: Can you handle this?}

p19: ,an\_d\_ the input domain
\fixed{}

p20: ``it is immediate to calculate that p=0.25" $\rightarrow$ rephrase to improve clarity
\fixed{}

p20: the actual value of p \_is\_ close to its extremes
\fixed{}

p21: provide\_s\_ a significantly better scalability (or: scales significantly better)
\fixed{}

p22: in other areas of program analysis\_,\_ a mutually\_-\_reinforcing cycle
\fixed{}

\end{document}
